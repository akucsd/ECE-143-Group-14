# -*- coding: utf-8 -*-
"""ECE143.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-8bkW0qJjKhjbTuZefhobAN_arETSKNA
"""

#Import libraries

from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report
import pandas as pd

#load the dataset

file_path = '/content/ObesityDataSet_raw_and_data_sinthetic.csv'

dataset = pd.read_csv(file_path)

print(dataset.head())

dataset.columns

#added BMI as one of the column in the dataset

#Body fat classification is determined by body mass index (BMI), so I calculated BMI and added each individual's BMI as a new column
dataset['BMI'] = dataset['Weight']/(dataset['Height']**2)

#Reorder columns to put BMI immediately after Height and Weight
dataset = dataset[['Gender', 'Age', 'Height', 'Weight','BMI', 'family_history_with_overweight',
       'FAVC', 'FCVC', 'NCP', 'CAEC', 'SMOKE', 'CH2O', 'SCC', 'FAF', 'TUE',
       'CALC', 'MTRANS', 'NObeyesdad']]
#Check if the new column was calculated and placed correctly
dataset.head()

num_rows, num_columns = dataset.shape
dataset.shape

#split the data into feature(X) and Target variable(y)
columns = ['Gender', 'Age', 'Height', 'Weight','BMI', 'family_history_with_overweight', 'FAVC', 'FCVC', 'NCP', 'CAEC', 'SMOKE', 'CH2O', 'SCC', 'FAF', 'TUE','CALC', 'MTRANS']
X = dataset [columns]
y = dataset ['NObeyesdad']

#Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the Decision Tree model
clf = DecisionTreeClassifier(random_state=42)

# Columns to one-hot encode
columns_to_encode = columns
print(columns_to_encode)
# Perform one-hot encoding on the specified columns
X_train_encoded = pd.get_dummies(X_train, columns=columns_to_encode, drop_first=True)
X_test_encoded = pd.get_dummies(X_test, columns=columns_to_encode, drop_first=True)

X_train_encoded

X_test_encoded

# Reapply one-hot encoding to the test set
X_test_encoded = pd.get_dummies(X_test, columns=columns_to_encode, drop_first=True)
X_test_encoded

# Align columns of X_train_encoded and X_test_encoded
X_train_encoded, X_test_encoded = X_train_encoded.align(X_test_encoded, join='left', axis=1, fill_value=0)
X_train_encoded

X_test_encoded

from sklearn.preprocessing import LabelEncoder

# Create an instance of LabelEncoder
label_encoder = LabelEncoder()

# Fit and transform the target variable for training data
y_train_encoded = label_encoder.fit_transform(y_train)

# Transform the target variable for test data
y_test_encoded = label_encoder.transform(y_test)

clf.fit(X_train_encoded, y_train_encoded)

# Make predictions
y_pred_encoded = clf.predict(X_test_encoded)
# Inverse transform to get original labels
y_pred = label_encoder.inverse_transform(y_pred_encoded)
y_pred

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

# Display classification report
print('Classification Report:')
print(classification_report(y_test, y_pred))

from sklearn.metrics import confusion_matrix
# Assuming y_test and y_pred are your test set labels and predicted labels
conf_matrix = confusion_matrix(y_test, y_pred)
# Extract values from confusion matrix
TN, FP, FN, TP = conf_matrix.ravel()[:4]
# Now, FP and FN are available for further analysis
print("False Positives (FP):", FP)
print("False Negatives (FN):", FN)
print("True Positives (TP):", TP)
print("True Negatives (TN):", TN)
print(conf_matrix.shape)

#dropped features and checked the accuracy

#Body fat classification is determined by body mass index (BMI), so I calculated BMI and added each individual's BMI as a new column
dataset['BMI'] = dataset['Weight']/(dataset['Height']**2)

#Reorder columns to put BMI immediately after Height and Weight
dataset = dataset[['Gender', 'Age', 'Height', 'BMI',
       'FAVC', 'FCVC', 'NCP', 'CAEC','CH2O', 'SCC', 'FAF', 'TUE',
       'CALC', 'MTRANS', 'NObeyesdad']]
#Check if the new column was calculated and placed correctly
dataset.head()

num_rows, num_columns = dataset.shape
dataset.shape

#split the data into feature(X) and Target variable(y)
columns = ['Gender', 'Age', 'Height', 'BMI', 'FAVC', 'FCVC', 'NCP', 'CAEC', 'CH2O', 'SCC', 'FAF', 'TUE','CALC', 'MTRANS']
X = dataset [columns]
y = dataset ['NObeyesdad']

#Split the dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the Decision Tree model
clf = DecisionTreeClassifier(random_state=42)

# Columns to one-hot encode
columns_to_encode = columns
print(columns_to_encode)
# Perform one-hot encoding on the specified columns
X_train_encoded = pd.get_dummies(X_train, columns=columns_to_encode, drop_first=True)
X_test_encoded = pd.get_dummies(X_test, columns=columns_to_encode, drop_first=True)

X_train_encoded

X_test_encoded

# Reapply one-hot encoding to the test set
X_test_encoded = pd.get_dummies(X_test, columns=columns_to_encode, drop_first=True)
X_test_encoded

# Align columns of X_train_encoded and X_test_encoded
X_train_encoded, X_test_encoded = X_train_encoded.align(X_test_encoded, join='left', axis=1, fill_value=0)
X_train_encoded

X_test_encoded

from sklearn.preprocessing import LabelEncoder

# Create an instance of LabelEncoder
label_encoder = LabelEncoder()

# Fit and transform the target variable for training data
y_train_encoded = label_encoder.fit_transform(y_train)

# Transform the target variable for test data
y_test_encoded = label_encoder.transform(y_test)

clf.fit(X_train_encoded, y_train_encoded)

# Make predictions
y_pred_encoded = clf.predict(X_test_encoded)
# Inverse transform to get original labels
y_pred = label_encoder.inverse_transform(y_pred_encoded)
y_pred

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

# Display classification report
print('Classification Report:')
print(classification_report(y_test, y_pred))

from sklearn.metrics import confusion_matrix
# Assuming y_test and y_pred are your test set labels and predicted labels
conf_matrix = confusion_matrix(y_test, y_pred)
# Extract values from confusion matrix
TN, FP, FN, TP = conf_matrix.ravel()[:4]
# Now, FP and FN are available for further analysis
print("False Positives (FP):", FP)
print("False Negatives (FN):", FN)
print("True Positives (TP):", TP)
print("True Negatives (TN):", TN)
print(conf_matrix.shape)